## 인증과 인가
### 간단한 예시

>> 누군가 벨을 울린다(로그인 요청) -> 인터폰을 통해 확인하고, 내가 아는 사람이면 문을 열어준다. (인증)
>> 들어온 사람은 거실에서 마음껏 놀 수 있지만 침실에서는 놀 수 없다. (인가) 

이 예시를 바탕으로 몇가지 인증 방법에 대해 알아보자.

####  Basic 인증
최초 로그인 후 ```HTTP 요청 헤더```의 ```Authorization```부분에 ```<ID>:<Password>```의 형식으로 이어붙인뒤 인코딩 한 문자열을 보낸다.
##### 단점
* 아이디와 비밀번호가 노출된다. 인코딩이 되었지만 이는 보안을 위한 요소가 아니다. 디코딩하면 끝!
* HTTP와 사용하면 보안에 큰 issue가 생긴다.
* 마이크로 서비스 기반의 애플리케이션을 운영할 경우 서비스가 많아질 수록 DB접근량이 많아져 부하가 커진다.
* 인증 서버에 장애가 나면 모든 서버에 장애가 발생한다.

기본적인 수준의 인증 방식은 보안에 취약할 뿐만 아니라, 서버에 과부하를 가져올 수 있는 위험성이 존재한다.
그렇다면 다른 인증 방식에는 무엇이 있을까?

#### 토큰 기반 인증
사용자를 구분할 수 있는 문자열인 ```Token```을 발행하여 이를 통해 인증된 사용자인지 검증하는 것이다.
하지만 이 토큰기반인증도 인증서버에 저장하고 매번 접근시에 인증 서버를 거쳐야만 한다.
아이디와 패스워드가 직접 표시되지않고 유효시간을 통해 관리할 수 있다는 장점이 있지만, 단점 또한 존재한다.
##### 단점
* 여전히 인증서버를 거쳐 사용자의 접속 정보를 인증한다
* Basic인증 방식의 부하 관련 단점을 모두 갖고있다.

이 토큰 기반 인증의 단점까지 해결하기 위해 또다른 인증 방식이 존재한다.

#### JSON웹 토큰
JWT는 ```{header}.{payload}.{signature}``` 형태의 JSON 토큰이다.  
JWT또한 서버에서 생성하지만, 헤더와 페이로드를 생성한 후 전자서명을 하는 방식으로 인증이 이뤄진다.
##### 인증 방식
1. 사용자 정보를 바탕으로 header와 payload 생성
2. ```signature1``` = 생성된 header와 payload로 시크릿 키 전자서명, 인코딩 후 반환
3. 이후 인증 요청 시, 받은 토큰 디코드 ```header.payload.signature2```
4. ```signature3``` = header와 payload떼어내서 시크릿 키 전자서명
5. 만약 ```signature2 == signature3```, 인증 성공

JWT는 인증 서버를 거칠 필요가 없다. 부하에 안전하고 인증서버로 인한 장애가 전체의 장애로 이어지지 않는다.  
또한 서명정보를 비교하여 유효성을 검사하기 때문에 보안적인 측면에서도 양호하다.(하지만 탈취당하면 어쩔 수 없다. HTTPS와 함께 사용돼야 한다.)
